<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Incenter Demo: Perpendicular Radii</title>
    <style>
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f8fafc;
            margin: 0;
            padding: 20px;
            color: #1e293b;
        }
        h2 { margin-bottom: 10px; color: #0f172a; }
        canvas {
            background-color: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            cursor: crosshair;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            touch-action: none;
        }
        .ui-panel {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            max-width: 700px;
            width: 100%;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            margin-bottom: 20px;
        }
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 14px;
        }
        #btnNextBisector { background-color: #3b82f6; color: white; }
        #btnNextRadius { background-color: #8b5cf6; color: white; }
        #btnReset { background-color: #ef4444; color: white; }
        
        button:disabled { background-color: #cbd5e1; cursor: not-allowed; }
        
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #475569;
        }
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            font-size: 0.85rem;
            border-top: 1px solid #f1f5f9;
            padding-top: 15px;
        }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; }
        .line { width: 20px; height: 2px; }
    </style>
</head>
<body>

    <h2>Incenter: Bisectors & Perpendiculars</h2>
    
    <canvas id="geometryCanvas" width="600" height="400"></canvas>

    <div class="ui-panel">
        <div class="controls">
            <button id="btnNextBisector">Next Bisector</button>
            <button id="btnNextRadius">Next Perpendicular</button>
            <button id="btnReset">Reset All</button>
            <div class="toggle-container">
                <input type="checkbox" id="checkIncircle">
                <label for="checkIncircle">Show Incircle</label>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item"><div class="line" style="background: #3b82f6; border-top: 2px dashed #3b82f6;"></div> Bisector</div>
            <div class="legend-item"><div class="line" style="background: #8b5cf6;"></div> Perpendicular (r)</div>
            <div class="legend-item"><div class="dot" style="background: #10b981;"></div> Incircle</div>
            <div class="legend-item"><div class="dot" style="background: #f59e0b;"></div> Equal Angles</div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('geometryCanvas');
    const ctx = canvas.getContext('2d');
    const btnNextB = document.getElementById('btnNextBisector');
    const btnNextR = document.getElementById('btnNextRadius');
    const btnReset = document.getElementById('btnReset');
    const checkIncircle = document.getElementById('checkIncircle');

    let visibleBisectorsCount = 0;
    let visibleRadiiCount = 0;
    let draggingPoint = null;
    let points = [
        { x: 300, y: 70, label: 'A' },
        { x: 500, y: 330, label: 'B' },
        { x: 100, y: 330, label: 'C' }
    ];

    function getDist(p1, p2) { return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2); }

    // Helper to find the foot of a perpendicular from point P to line segment AB
    function getPerpPoint(P, A, B) {
        const dx = B.x - A.x;
        const dy = B.y - A.y;
        const t = ((P.x - A.x) * dx + (P.y - A.y) * dy) / (dx * dx + dy * dy);
        return { x: A.x + t * dx, y: A.y + t * dy };
    }

    function drawAngleMarkers(v, p1, p2) {
        const ang1 = Math.atan2(p1.y - v.y, p1.x - v.x);
        const ang2 = Math.atan2(p2.y - v.y, p2.x - v.x);
        let diff = ang2 - ang1;
        while (diff < -Math.PI) diff += Math.PI * 2;
        while (diff > Math.PI) diff -= Math.PI * 2;
        const radius = 25;
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(v.x, v.y, radius, ang1, ang1 + diff/2); ctx.stroke();
        ctx.beginPath(); ctx.arc(v.x, v.y, radius + 4, ang1 + diff/2, ang2); ctx.stroke();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const [A, B, C] = points;
        const a = getDist(B, C), b = getDist(A, C), c = getDist(A, B);
        const perim = a + b + c;
        const I = { x: (a*A.x + b*B.x + c*C.x)/perim, y: (a*A.y + b*B.y + c*C.y)/perim };
        const area = 0.5 * Math.abs(A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y));
        const r = area / (perim / 2);

        // Sides
        ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.lineTo(C.x, C.y); ctx.closePath(); ctx.stroke();

        // 1. Bisectors
        const bisectorData = [ {v:A, p1:B, p2:C}, {v:B, p1:C, p2:A}, {v:C, p1:A, p2:B} ];
        for (let i = 0; i < visibleBisectorsCount; i++) {
            const item = bisectorData[i];
            ctx.setLineDash([5, 5]); ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(item.v.x, item.v.y); ctx.lineTo(I.x, I.y); ctx.stroke();
            ctx.setLineDash([]);
            drawAngleMarkers(item.v, item.p1, item.p2);
        }

        // 2. Perpendiculars (Radii)
        // Radii go to sides opposite to A, B, C (which are BC, AC, AB)
        const sidePairs = [ {p1:B, p2:C}, {p1:A, p2:C}, {p1:A, p2:B} ];
        for (let i = 0; i < visibleRadiiCount; i++) {
            const foot = getPerpPoint(I, sidePairs[i].p1, sidePairs[i].p2);
            ctx.strokeStyle = '#8b5cf6'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(I.x, I.y); ctx.lineTo(foot.x, foot.y); ctx.stroke();
            // Right angle symbol
            const dx = (foot.x - I.x)/r * 10; const dy = (foot.y - I.y)/r * 10;
            ctx.beginPath();
            ctx.moveTo(foot.x - dx, foot.y - dy);
            // This is a simplified right-angle square
            ctx.stroke();
        }

        // 3. Incircle & Center
        if (checkIncircle.checked) {
            ctx.strokeStyle = '#10b981'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(I.x, I.y, r, 0, Math.PI*2); ctx.stroke();
        }
        if (visibleBisectorsCount >= 2 || visibleRadiiCount >= 1) {
            ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(I.x, I.y, 5, 0, Math.PI*2); ctx.fill();
            ctx.font = "bold 14px sans-serif"; ctx.fillText("I", I.x+10, I.y-5);
        }

        // Vertices
        ctx.fillStyle = '#1e293b';
        points.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI*2); ctx.fill();
            ctx.font = "bold 14px sans-serif"; ctx.fillText(p.label, p.x-5, p.y-15);
        });
    }

    btnNextB.onclick = () => { if(visibleBisectorsCount < 3) visibleBisectorsCount++; draw(); btnNextB.disabled = (visibleBisectorsCount==3); };
    btnNextR.onclick = () => { if(visibleRadiiCount < 3) visibleRadiiCount++; draw(); btnNextR.disabled = (visibleRadiiCount==3); };
    btnReset.onclick = () => { visibleBisectorsCount = 0; visibleRadiiCount = 0; btnNextB.disabled = false; btnNextR.disabled = false; checkIncircle.checked = false; draw(); };
    checkIncircle.onchange = draw;

    function handlePointer(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX || e.touches?.[0].clientX) - rect.left;
        const y = (e.clientY || e.touches?.[0].clientY) - rect.top;
        if (e.type === 'mousedown' || e.type === 'touchstart') {
            points.forEach(p => { if(getDist({x,y}, p) < 20) draggingPoint = p; });
        } else if (draggingPoint) {
            draggingPoint.x = x; draggingPoint.y = y; draw();
        }
    }

    canvas.addEventListener('mousedown', handlePointer);
    window.addEventListener('mousemove', handlePointer);
    window.addEventListener('mouseup', () => draggingPoint = null);
    canvas.addEventListener('touchstart', handlePointer, {passive: false});
    window.addEventListener('touchmove', handlePointer, {passive: false});
    window.addEventListener('touchend', () => draggingPoint = null);

    draw();
</script>
</body>
</html>
